\section{Design}\label{sec:design}


\input{sections/design_problems}
\input{sections/design_goals}


\subsection{Conceptual model}\label{sec:conceptual_model}

The data model of the presented system is extremely simple. There is no requirement to design a schema or to differentiate between entities and relationships. Yet, \emph{all} structured data can be represented in the system as long as data is fully normalized (6NF).

\begin{itemize}
  \item The basic unit of information is a \emph{fact}, a triple \lisp{[e a v]} containing values representing \emph{entity}, \emph{attribute}, and \emph{value}.

  \item Over time, facts are \emph{asserted} and \emph{retracted}, accreted as part of a \emph{transaction}.

  \item The database and all changes to its state over time are fully described by the transaction log of assertions and retractions of facts.
\end{itemize}

\paragraph{Indexing.}

EAV systems commonly keep a number of sorted indices (see \autoref{tbl:indices}) to allow the data to be retrieved from multiple "angles", depending on the need of the query. Index structures are named after the \emph{nesting order} in which the elements of the facts are arranged. Not all database systems maintain the same indices. In this case, the system keeps four indices covering the following common use cases:
\begin{itemize}
  \item EAVT, the canonical order, which \emph{maps} an entity to its attributes like a document,
  \item AEVT, for finding entities which \emph{have} a certain attribute set
  \item AVET, for \emph{filtering} entities by a known attribute set to a known value,
  \item VAET, for \emph{searching} over all attributes of all entities by a known value.
\end{itemize}


\newcolumntype{s}{>{\hsize=.5\hsize}X}

\begin{table}[]
  \label{tbl:indices}
  \caption{Impact of the index sort order on the area of application}
  \begin{tabularx}{\textwidth}{|l|s|s|X|}
  \hline
  \textbf{index} & \textbf{name}               & \textbf{feels like}      & \textbf{good for}                                     \\ \hline
  \lisp{:eavt}          & "entity-oriented"           & document store           & accessing various attributes of a known entity        \\ \hline
  \lisp{:aevt}          & "attribute-entity-oriented" & column store             & accessing the same attribute of various entities      \\ \hline
  \lisp{:avet}          & "attribute-value-oriented"  & filtering a column store & finding entities by the value of a specific attribute \\ \hline
  \lisp{:vaet}          & "value-oriented"            & searching everything     & searching over all values, regardless of attribute    \\ \hline
  \end{tabularx}
\end{table}

For example, here is a simple example to pull out the name of a known patient, using only the \lisp{get-in} function of the Clojure core library on the \lisp{:eavt} index:

\begin{center}
  \lisp{(get-in db [:eavt :patient/91 :name])}
\end{center}

One can also leave out the attribute, and get back a map (as a conceptual \emph{document}) containing all known attributes related to that entity.

\begin{center}
  \lisp{(get-in db [:eavt :patient/91])}
\end{center}

Performing a search by name over all patients is similarly trivial using the \lisp{:avet} index, with the result

\begin{center}
  \lisp{(get-in db [:avet :name "Hye-mi"])}
\end{center}



\subsection{Query language}

The query language of the system is a greatly simplified language modeled after the pattern matching relational query language used in Datomic, which is in turn a Lisp variant of the Datalog \cite{abiteboul1988datalog} language expressed using the syntactic forms of Clojure's \gls{edn}.

The choice of language is arbitrary -- any relational language would suffice -- and the core of the database does not depend on any query language capabilities Modeling the language after the one used in Datomic was chosen because because not only has the edn notation become a de-facto standard for other EAV databases like Crux, EVA, and Datascript, but because the shape of each query clause maps naturally to the representation of a fact in canonical EAV order.

See \autoref{lst:example_query} for an query consisting of four query clauses (the \lisp{:where} part) performing an implicit join, and a final projection (\lisp{:find}) to extract the values bound to the \emph{\gls{lvar}} symbols \lisp{?name} and \lisp{?location}. For example, the query clause \lisp{[?p :name ?name]} applied to the fact \lisp{[:person/123 :name "Hye-mi"]} would result in \emph{binding} the lvar \lisp{?p} to the value \lisp{:person/123}, and the lvar \lisp{?name} to the value \lisp{"Hye-mi"}. Other clauses are bound likewise. Note that multiple occurrences of the same lvar prompt \emph{unification} with the same value, creating an implicit \emph{join}. The order of the query clauses has no semantic meaning.

Performing a query entails applying the \lisp{q} function to a database value and a query. Clients can thus decide whether to leverage the query language via loading a library, or just access the data via the index structures directly.

\begin{lstlisting}[label={lst:example_query},caption="Who from Korea is working for whom?"]
'[:find [?name ?company]
  :where [[?p :works-for ?e]
          [?e :name ?company]
          [?p :name ?name]
          [?p :location "Korea"]]]
\end{lstlisting}

\paragraph{Temporal and bitemporal queries.}
As stated in \autoref{sec:nongoals}, the (bi-)temporal aspects of the described system are secondary -- they are to be used for infrequent auditing purposes. Consequently, the design of the indexing and query mechanisms can be greatly simplified be forgoing bitemporal indexing strategies such as \cite{nascimento1995ivtt}.

As the query function simply takes a database as a \emph{value}, a \emph{filtering function} can be applied the the database beforehand. The \lisp{keep} function in \autoref{lst:queryfilter} returns a structurally shared and lazy copy of the database filtered by arbitrary bounds of the relevant timestamps $t_x$ and $t_v$.

\begin{lstlisting}[label={lst:queryfilter},caption=Applying a temporal filter before querying,morekeywords={keep,q,<,>}]
  (q (keep
       ($\lambda$ [$t_x$ $t_v$]
         (and (> $t_v$ 300) (< $t_v$ 500)
              (< $t_x$ 700)))
       db) query)
  \end{lstlisting}


A common use case in auditing is to retrieve the \emph{history} of all attributes related to a given entity over time. The \lisp{history} function takes a database value (optionally composed with a filtering function as described above) and an entity value, and returns an ordered slice of the log with transactions relevant to the requested entity.



\subsection{Publication and subscription}

TODO figure out how replication of everything

- do it meteor-like.

- server controls publication via :where part

- do not replicate past (superseded/retracteed) fast

- deep history traversal should run on server

- server-side queries should run as callable "actions"
Authorization / selective publishing / field-level access control
