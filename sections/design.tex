\section{Design}\label{sec:design}


\input{sections/design_problems}
\input{sections/design_goals}


\subsection{Conceptual model}\label{sec:conceptual_model}

TODO

\begin{itemize}
  \item A fact is a triple \lisp{[e a v]}

  \item A transition is a fact with an indicator whether it is an assertion \lisp{[:+ e a v]} or retraction \lisp{[:- e a v]}.

  \item A transaction is a list of transitions epochally applied at the same logical time and a pointer to the transaction, \lisp{tx}, which holds the value of a (newly-generated) transaction entity id: \lisp{[[+ ... tx] [- ... tx] [+ ... tx]]}

  \item The log is a single ordered list of transactions.

  \item The database is fully described by the log.

\end{itemize}

\subsection{Indexing}

TODO

Commonly used index sort orders in EAV systems and their strengths are compared in \autoref{tbl:indices}.

\newcolumntype{s}{>{\hsize=.5\hsize}X}

\begin{table}[]
  \label{tbl:indices}
  \caption{Impact of the index sort order on the area of application}
  \begin{tabularx}{\textwidth}{|l|s|s|X|}
  \hline
  \textbf{index} & \textbf{name}               & \textbf{feels like}      & \textbf{good for}                                     \\ \hline
  \lisp{:eavt}          & "entity-oriented"           & document store           & accessing various attributes of a known entity        \\ \hline
  \lisp{:aevt}          & "attribute-entity-oriented" & column store             & accessing the same attribute of various entities      \\ \hline
  \lisp{:avet}          & "attribute-value-oriented"  & filtering a column store & finding entities by the value of a specific attribute \\ \hline
  \lisp{:vaet}          & "value-oriented"            & searching everything     & searching over all values, regardless of attribute    \\ \hline
  \end{tabularx}
\end{table}



\subsection{Query language}

This section describes the ideas behind the query language, which is a greatly simplified language modeled after the relational query language used in Datomic, which is in turn a Lisp variant of the Datalog \cite{abiteboul1988datalog} language expressed using the syntactic forms of Clojure's \gls{edn}.

The choice of language is arbitrary -- any relational language would suffice -- and the core of the database does not depend on any query language capabilities Modeling the language after the one used in Datomic was chosen because because not only has the edn notation become a de-facto standard for other EAV databases like Crux, EVA, and Datascript, but because the shape of each query clause maps naturally to the representation of a fact in canonical EAV order.

See \autoref{lst:example_query} for an query consisting of four query clauses (the \lisp{:where} part) performing an implicit join, and a final projection (\lisp{:find}) to extract the values bound to the \emph{\gls{lvar}} symbols \lisp{?name} and \lisp{?location}. For example, the query clause \lisp{[?p :name ?name]} applied to the fact \lisp{[:person/123 :name "Hye-mi"]} would result in \emph{binding} the lvar \lisp{?p} to the value \lisp{:person/123}, and the lvar \lisp{?name} to the value \lisp{"Hye-mi"}. Other clauses are bound likewise. Note that multiple occurrences of the same lvar prompt \emph{unification} with the same value, creating an implicit \emph{join}. The order of the query clauses has no semantic meaning.

Performing a query entails applying the \lisp{q} function to a database value and a query. Clients can thus decide whether to leverage the query language via loading a library, or just access the data via the index structures directly.

\begin{lstlisting}[label={lst:example_query},caption=Example edn Datalog query]
'[:find [?name ?company ?location]
  :where [[?p :works-for ?e]
          [?e :name ?company]
          [?p :name ?name]
          [?p :location ?location]]]
\end{lstlisting}

\paragraph{Temporal and bitemporal queries.}
As stated in \autoref{sec:nongoals}, the (bi-)temporal aspects of the described system are secondary -- they are to be used for infrequent auditing purposes. Consequently, the design of the indexing and query mechanisms can be greatly simplified be forgoing bitemporal indexing strategies such as \cite{nascimento1995ivtt}.

As the query function simply takes a database as a \emph{value}, a \emph{filtering function} can be applied the the database beforehand. The \lisp{keep} function in \autoref{lst:queryfilter} returns a structurally shared and lazy copy of the database filtered by arbitrary bounds of the relevant timestamps $t_x$ and $t_v$.

\begin{lstlisting}[label={lst:queryfilter},caption=Applying a temporal filter before querying,morekeywords={keep,q,<,>}]
  (q (keep
       ($\lambda$ [$t_x$ $t_v$]
         (and (> $t_v$ 300) (< $t_v$ 500)
              (< $t_x$ 700)))
       db) query)
  \end{lstlisting}


A common use case in auditing is to retrieve the \emph{history} of all attributes related to a given entity over time. The \lisp{history} function takes a database value (optionally composed with a filtering function as described above) and an entity value, and returns an ordered slice of the log with transactions relevant to the requested entity.



\subsection{Publication and subscription}

TODO figure out how replication of everything

- do it meteor-like.

- server controls publication via :where part

- do not replicate past (superseded/retracteed) fast

- deep history traversal should run on server

- server-side queries should run as callable "actions"
Authorization / selective publishing / field-level access control
