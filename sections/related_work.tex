\cleardoublepage
\section{Related Work}\label{sec:related_work}



\paragraph{\gls{RAD}.} Scaling developer productivity as the team size goes $n \to 1$ on data-intensive near real time collaborative line-of-business applications goes back to the \gls{RAD} movement of the 1990s sparked by tools such as the Delphi suite \cite{mackay2000reconfiguring}, PowerBuilder \cite{zubeck1997implementing}, Lotus Notes \cite{zubeck1997implementing}, and FileMaker
\cite{chen2010developing}.

\paragraph{MUMPS.} On the aspects of near real time state synchronization combined with RAD tooling, a notable mention is the \gls{MUMPS} \cite{bowie1979methods} dating back to the year 1966. An extremely terse programming language combined with a runtime system featuring built-in persistence mechanisms. This "global database" is a subscripted array which replicates \emph{code and data} across machines in near real time. Major hospitals and financial institutions continue to run their daily operational workloads on various evolutions of MUMPS systems today \cite{aller2018evolution}.

\paragraph{Firebase and Parse.} These services brought real time state synchronization to web and mobile applications starting in 2011. Firebase is a proprietary managed service operated by Google. Its data model is based on a global mutable structure in \gls{JSON} and allows only rather simplistic filtering and navigational queries. Parse was a similar real time Backend-as-a-Service based on MongoDB and Redis which was active from 2011 to 2017. \cite{wingerath2019real}

\paragraph{Meteor.} This thesis is an evolution based on the author's experience running a \gls{SaaS} business built on the open source Meteor \cite{schmidt2014live} framework and the \gls{DDP} \cite{ddpspec} released in 2012. Meteor allows clients to transparently subscribe to the results of predefined MongoDB queries updating live over arbitrary durations. Synchronization is achieved by the server watching the operations log of the database (called "oplog tailing") \cite{wingerath2019real}, keeping track of the documents and queries of each connected client, and computing delta changes to send back to the client. See \autoref{tbl:dbcomparison} for a comparison of Meteor with other data management approaches.

Clients cache the received documents in a local instance of MongoDB implemented in JavaScript (called Minimongo), enabling arbitrary local queries with no latency. Combined with a functional-reactive view library such as React to bind the management of a view's lifecycle with its data subscriptions, this setup gives the impression of data "just being here" on the client with almost no programmatic overhead.

The major problem of Meteor is its absolute dependence on MongoDB and the ensuing lack of a relational data model, i.e. no joins and requiring to denormalize data, leading to incidental complexity and the $n+1$ query problem.

Other databases which allow subscribing to the result set of a query include RxDB for JavaScript \cite{wingerath2019real}, Supabase which is built in Erlang/Elixir and adds query-subscription capabilities to Postgres \cite{supabase}.

\begin{table}[]
  \label{tbl:dbcomparison}
  \caption{Comparison Meteor with other database and stream processing systems \cite{wingerathcase}}
  \begin{tabular}{r|c|c|c|c|}
    \cline{2-5}
                                              & \textbf{DBMS}                                                & \textbf{\begin{tabular}[c]{@{}c@{}}Real-time\\ database\end{tabular}}            & \textbf{\begin{tabular}[c]{@{}c@{}}Data stream\\ management\end{tabular}} & \textbf{\begin{tabular}[c]{@{}c@{}}Stream\\ processing\end{tabular}}     \\ \hline
    \multicolumn{1}{|r|}{\textbf{data}}       & \multicolumn{2}{c|}{\begin{tabular}[c]{@{}c@{}}persistent\\ collections\end{tabular}}                                                           & \multicolumn{2}{c|}{\begin{tabular}[c]{@{}c@{}}persistent \& ephemeral\\ streams\end{tabular}}                                                       \\ \hline
    \multicolumn{1}{|r|}{\textbf{processing}} & one-time                                                     & \begin{tabular}[c]{@{}c@{}}one-time \&\\ continuous\end{tabular}                 & \multicolumn{2}{c|}{continuous}                                                                                                                      \\ \hline
    \multicolumn{1}{|r|}{\textbf{access}}     & random                                                       & \begin{tabular}[c]{@{}c@{}}random \&\\ sequential\end{tabular}                   & \multicolumn{2}{c|}{sequential}                                                                                                                      \\ \hline
    \multicolumn{1}{|r|}{\textbf{streams}}    & \multicolumn{3}{c|}{structured}                                                                                                                                                                                             & \begin{tabular}[c]{@{}c@{}}structured \&\\ unstructured\end{tabular}     \\ \hline
    \multicolumn{1}{l|}{}                     & \begin{tabular}[c]{@{}c@{}}PostgreSQL\\ MongoDB\end{tabular} & \begin{tabular}[c]{@{}c@{}}Firebase,\\ Meteor,\\ RethinkDB,\\ Parse\end{tabular} & \begin{tabular}[c]{@{}c@{}}Influx,\\ PipelineDB,\\ SQLStream\end{tabular} & \begin{tabular}[c]{@{}c@{}}Storm,\\ Samza,\\ Flink,\\ Spark\end{tabular} \\ \cline{2-5} 
    \end{tabular}
  \end{table}



\paragraph{Datomic.} Most of the design tenets for the project described in \autoref{sec:tenets} originate from the database Datomic \cite{hickey2012dbvalue} which was created by the author of the Clojure programming language in 2012. Its data model is a monotemporal (transaction time \gls{tx} only) and immutable log of assertions and retractions of EAV facts, with first-class transactions being reified as regular queryable facts themselves. Datomic requires a minimal schema to be specified upfront.

Instead of thinking of the database as a single \emph{place} to send queries to and receive tuples from, Datomic separates its components as follows to achieve horizontal read scalability, turning the classical model of a database "inside out" \cite{kleppmann2017designing}:
\begin{itemize}
  \item There is a \emph{generic} stateful distributed storage layer, which may be backed by any pluggable implementation (SQL, Redis, Riak, Kafka, files, memory...). The storage layer keeps all data in the form of tuples and various indices. \cite{hickey2019datomic}.
  \item Application servers (called "peers") operate on a working set of tuples in memory. They perform queries themselves \emph{locally on their own copy of the data.} Tuples are cached locally as needed and are lazily loaded from the storage layer over the (local) network, where disk locality is considered irrelevant \cite{ananthanarayanan2011disk}. As put by the author: "perception does not require coordination \cite{hickey2012values}", yet consistency and caching are trivial because tuples are immutable.
  \item All write transactions -- represented as data structures -- go through a \emph{single} instance of the \emph{transactor} component, which is the only part of the system that may write to the storage backend. Because it is one single threaded instance, it can impose a global order on all incoming transactions. Conversely, the transactor is the bottleneck for write throughput, as well as a single point of failure for which a second instance should be operated in a hot failover configuration. Peers can place first-class functions into the database, and call them as part of a transaction to enforce arbitrary data invariants \cite{datomicdocs}.
\end{itemize}


\paragraph{Crux.} Rooted in the same core principles as Datomic but having taken some different architectural choices, Crux is an efficient \emph{bitemporal} schemaless unbundled document database. For a detailed comparison with Datomic, see \cite{juxtcrux}.

\paragraph{Datascript et al.} Similarly inspired by Datomic, DataScript \cite{prokopov15datascript} is an immutable schemaless in-memory EAV store. It lacks notion of time because it is designed to manage frequently changing client-side state of a \gls{SPA} within the browser for the lifetime of a session, using limited memory.

Several attempts exist to bridge the gap between a Datomic-like database on the server and a DataScript instance on the client used simultaneously for client-only view state as well as for caching tuples from the server \cite{small16datscript}; as well as the gap between that database and the view layer \cite{parker15posh,krivosheev19reposh}. Datahike \cite{datahike} is a port of DataScript back to the server, where it adds durable persistence. It aims to be a single-node replacement for Datomic suitable small projects.

Mozilla Mentat \cite{mozillamentat} was an attempt at a performant embeddable implementation in Rust of a combination of ideas from Datomic, DataScript, and SQLite.

Eva \cite{eva} is an open source monotemporal EAV database very similar to and compatible with the \gls{API} of Datomic, though the project appears to be abandoned in a feature-complete "alpha" quality stage.

Ittyon \cite{ittyon} is a Clojure library to manage distributed state in games based on ideas from Entity-Component Systems (ECS) combined with the EAV+$t_x$ data model. Its client/server architecture via \emph{channels} inspired the implementation of the prototype described in \autoref{sec:implementation}.

\paragraph{LogicBlox.} A notable proprietary commercial RAD self-serve database system with an integrated programming language based on Datalog, LogicBlox \cite{aref2015design} similarly aims to reduce incidental complexity of developing line-of-business applications with a focus on probabilistic and predictive analytics of large business data sets. Its developers have contributed a novel efficient algorithm for incremental view maintenance for Datalog systems \cite{veldhuizen2012leapfrog}.


\paragraph{Hyperfiddle.} Built on Datomic to interactively create a \gls{UI} for database applications, the ongoing Hyperfiddle project \cite{getz18hyperfiddle} aims to be a \gls{DSL} to fully describe an application using only plain expressions of \gls{edn}.


\paragraph{Eve.} Ambitious but ultimately abandoned, the Eve project \cite{eve} was an attempt to reinvent programming for "humans first" through a combination of development environment, database, and a novel relational and reactive programming language where e.g. the concept of identifier scope is abandoned, and the order of statements has no semantics.
