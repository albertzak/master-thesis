\section{Implementation}\label{sec:implementation}

The following subsections describe the implementation of the design.

\paragraph{Functional core, stateful shell.}
A guiding principle is to push impure computation and state towards the edge of the system. In fact, all of the described core functionality is implemented as pure functions operating on plain unadorned immutable data structures. Such purity allows the same core of the database to run unmodified on servers and on clients.


\subsection{Data model}
The implementation relies heavily on the lazy immutable default data structures \cite{hickey2009persistent} provided by the Clojure core library, which remain performant even when used in strange ways thanks to structural sharing \cite{okasaki1999purely}.



\begin{itemize}
\item A \emph{fact} is represented as a vector, its elements can be of any Clojure value type.

\begin{center}
  \lisp{[e a v]}
\end{center}

\item A \emph{transition} is a vector containing the splatted fact as its first three elements, along with an indicator whether it is an assertion (\lisp{:+}) or retraction (\lisp{:-})

\begin{center}
  \lisp{[e a v :+]}
\end{center}

\item A \emph{transaction} is a vector of transitions, requested by the client to be atomically applied to the log \emph{by the server at some point in the future.} A transaction may contain \emph{meta facts} about itself (using the \lisp{:tx-meta} entity).

\begin{center}
  \lisp{[[e a v :-] [e a v :+] [:tx-meta a v]]}
\end{center}


\item A \emph{commit} is a transaction that was successfully applied by the server, meaning that any consistency criteria succeeded and the server's state was updated. A commit is the successful response to a transaction request, and is broadcast to all connected clients. It has similar shape and contents as the transaction it represents. Each non-meta transition of the committed transaction contains as its last element the same newly-generated transaction entity reference \lisp{txe}. There is also now at least the $t_x$ transaction meta fact added, and optionally any derived facts.

\begin{center}
  \lisp{
    [[e a v :+ txe]
     [e a v :- txe]
     [txe :tx $t_x$]]
  }
\end{center}


% \item A \emph{commit} is a transaction with a tx timestamp: \lisp{[2020 [:+ ...] [:- ...] [:+...]]}
% \item The \emph{log} is an ordered list of commits. All changes over time to the database are fully described by the log.
% \item An \emph{index} is an associative nested structure 3 layers deep: {:avet {:name {"Hye-mi" {:patient/91 :tx/31}}}} (where's the bitemporality in the index?)
% \item The database additionally keeps a vector of four indices: EAVT, AVET, VAET, AEVT for efficient querying.
% \end{itemize}



\paragraph{Transaction meta facts.}
A client may supply arbitrary transaction metadata, except $t_x$ which is always set by the server. To send metadata, the client adds transitions to the transaction, which have the magic value \lisp{:tx-meta} set as their entity. Before committing a transaction, the server will replace this value in the transitions with a newly generated entity.




\subsection{Bitemporality.}

TODO figure out

ivtt vs tx?

IVTT valid time trees \cite{nascimento1995ivtt}

TX layered [Rubinstein?]

as-of
since
as-if


\subsection{Pattern matching query engine}

The query engine is implemented as a completely separate and optional library.

\paragraph{Step 1: Filter the log by time}
depending on the query's time modifier medatata
(as-of, as-at)

\paragraph{Step 2: Build a filtering sieve triple}

The query clauses get transformed into a two element tuple, containing the sieve and a positional mapping back to the logic variable names.

[?e :name "Company A"]

; [[true #(= % :works-for) true] ["?p" nil "?e"]]
; [[true #(= % :name) #(= % "MyPlace")] ["?p" nil "?e"]]


\paragraph{Step 3: Decide index to use}
\autoref{tbl:lvartoindex}
The lvar that appears in each clause at the same position is the joining variable. This is a limitation, as a full query language should support arbitrary transitive joins.

\begin{table}
  \label{tbl:lvartoindex}
  \caption{Mapping of joining variable position to query index \cite{rubin15aosadb}}
  \begin{tabular}{|r|c|l|}
    \hline
    query clause & joining variable operates on & index to use \\ \hline
    \lisp{[?e :a :v]} & entity & \lisp{:avet} \\ \hline
    \lisp{[:e ?a :v]} & attribute & \lisp{:veat} \\ \hline
    \lisp{[:e :a ?v]} & value & \lisp{:eavt} \\ \hline
    \end{tabular}
\end{table}

\paragraph{Step 4: Run sieve function over filtered index}

According to the query design goals, the order of the query clauses have no semantic meaning, yet there is an effect on query evaluation performance: when the most restricting clauses are placed at the beginning, they are processed first and immediately reduce the cardinality of the set of potential results which the next clauses have to filter. Automatically optimizing clause order would require estimating the cardinality of the resulting sets, which is a complex undertaking and is thus omitted from this proof-of-concept implementation \cite{neumann2011characteristic, malik2007black}.



\paragraph{Step 5: Unification of result tuples with the query clause}



\subsection{Distribution and replication}

server offers publication: a fn taking optional client supplied parameters and returning a query data structure. may be arbitrarily timed.

clients send request to subscribe to a publication, optionally giving parameters

server runs publication function which may also perform authorization and gets a fully parameterized query returned.

the query is then added to and adds it to

server keeps all of a client's queries in memory.

completely separate server side tuple dataset for each client.

TODO: how to deregister clients?

TODO should all subscriptions have a (ordered?) uuid?
